// Generated by IcedCoffeeScript 108.0.12
(function() {
  var common, crypto, multi, multi_fn, x, _, _fn, _i, _j, _len, _len1, _ref, _ref1;

  _ = require('wegweg')({
    globals: true
  });

  crypto = require('crypto');

  multi = require('./multi-hashing-bbscoin');

  common = {
    LIST: [],
    MULTI: []
  };

  _ref = _.fns(multi);
  _fn = function(multi_fn) {
    var fn_name;
    common.MULTI.push(fn_name = 'MULTI_' + multi_fn);
    common.LIST.push(fn_name);
    return common[fn_name] = function(str) {
      var x;
      x = multi[multi_fn](Buffer.from(str, 'utf8'));
      return x.toString('hex');
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    multi_fn = _ref[_i];
    if (multi_fn === 'bcrypt' || multi_fn === 'scrypt' || multi_fn === 'scryptn' || multi_fn === 'boolberry' || multi_fn === 'sha1') {
      continue;
    }
    _fn(multi_fn);
  }

  common.LIST.push('sha1');

  common.sha1 = (function(str) {
    var x;
    x = crypto.createHash('sha1');
    x.update(Buffer.from(str, 'utf8'));
    return x.digest('hex');
  });

  common.LIST.push('sha256');

  common.sha256 = (function(str) {
    var x;
    x = crypto.createHash('sha256');
    x.update(Buffer.from(str, 'utf8'));
    return x.digest('hex');
  });

  common.LIST.push('sha512');

  common.sha512 = (function(str) {
    var x;
    x = crypto.createHash('sha512');
    x.update(Buffer.from(str, 'utf8'));
    return x.digest('hex');
  });

  common.find_fn = (function(char) {
    var chars;
    chars = "0123456789abcdef".split('');
    return common.MULTI[chars.indexOf(char)];
  });

  if (!module.parent) {
    log(common.LIST);
    _ref1 = common.LIST;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      x = _ref1[_j];
      log("`" + x + "()`", common[x]('GENESIS'));
    }
  } else {
    module.exports = common;
  }

}).call(this);
